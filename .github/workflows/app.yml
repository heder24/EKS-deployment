
name: 'App'

# name: Pull image from Docker Hub
# env:
#   DOCKER_USER: ${{secrets.DOCKER_HUB_USER}}
#   DOCKER_PASSWORD: ${{secrets.DOCKER_HUB_TOKEN}}
#   DOCKER_REPOSITORY: my-app
#   NODE_IMAGE_TAG: knote


on:
  push:
    branches: [ "main" ]
  pull_request:

permissions: write-all
  # contents: read
  # issues: write

jobs:
  terraform:
    name: 'Terraform'
    runs-on: ubuntu-latest
    environment: production

    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash
        working-directory: "./"

    steps:
    # Checkout the repository to the GitHub Actions runner
    - name: Checkout
      uses: actions/checkout@v3

    # # Install the latest version of Terraform CLI and configure the Terraform CLI configuration file with a Terraform Cloud user API token
    # - name: Setup Terraform
    #   uses: hashicorp/setup-terraform@v1
    #   with:
    #     cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

    # # Initialize a new or existing Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
    # - name: Terraform Init
    #   id: init
    #   run: terraform init

    # # Checks that all Terraform configuration files adhere to a canonical format
    # # - name: Terraform Format
    # #   run: terraform fmt -check

    # # Generates an execution plan for Terraform
    # - name: Terraform Plan
    #   id: plan
    #   run: terraform plan -input=false -no-color

   # Add a comment to pull requests with plan results
    - name: add-plan-comment
      id: comment
      uses: actions/github-script@v3
      if: github.event_name == 'pull_request'
      env:
        PLAN: "terraform\n${{ steps.plan.outputs.stdout }}"
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const output = `#### Terraform Format and Style üñå\`${{ steps.fmt.outcome }}\`
          #### Terraform Initialization ‚öôÔ∏è\`${{ steps.init.outcome }}\`
          #### Terraform Validation ü§ñ${{ steps.validate.outputs.stdout }}
          #### Terraform Plan üìñ\`${{ steps.plan.outcome }}\`
      
          <details><summary>Show Plan</summary>
          
          \`\`\`${process.env.PLAN}\`\`\`
          
          </details>
          
          *Pusher: @${{ github.actor }}, Action: \`${{ github.event_name }}\`, Working Directory: \`${{ env.tf_actions_working_dir }}\`, Workflow: \`${{ github.workflow }}\`*`;
            
          github.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: output
          })

    # Scan Terraform Config for Vulnerabilities

    - name: Run Snyk to check configuration files for security issues
      # Snyk can be used to break the build when it detects security issues.
      # In this case we want to upload the issues to GitHub Code Scanning
      continue-on-error: true
      uses: snyk/actions/iac@master
      env:
        SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      with:
        args: --sarif-file-output=snyk.scan
        sarif: false
    - name: Upload result to GitHub Code Scanning
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: snyk.scan



 - name: install kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest' # default is latest stable
      id: install

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-2

    # - name: install helm 
    #   uses: azure/setup-helm@v3
    #   with:
    #     version: 'latest' # default is latest (stable)
    #     token: ${{ secrets.GITHUB_TOKEN }} # only needed if version is 'latest'
    #   id: install

  #  - name: Pull Image from Docker Hub    
  #     run: |
  #       docker login -u ${{env.DOCKER_USER}} -p ${{env.DOCKER_PASSWORD}}
  #       docker pull ${{env.DOCKER_USER}}/${{env.DOCKER_REPOSITORY}}:${{env.NODE_IMAGE_TAG}}
      
    - name:  update kubeconfig
      run : |
         aws eks update-kubeconfig --region us-east-2 --name prod

    - name: Set K8s context
      uses: ossrs/k8s-set-context-action@v1
      with:
        kubeconfig: '${{ secrets.KUBECONFIG }}'

    # - name: Run K8s
    #   run: |-
    #     kubectl cluster-info
      
    - name: Set imagePullSecret
      uses: azure/k8s-create-secret@v4
      with:
        secret-name: 'regcred'
        container-registry-url: 'https://index.docker.io/v1/'
        container-registry-username: ${{ secrets.REGISTRY_USERNAME }}
        container-registry-password: ${{ secrets.REGISTRY_PASSWORD }}
      id: create-secret
        # aws eks update-kubeconfig --region us-east-2 --name prod

    - name: Deploy to EKS
      run: | 
        kubectl apply -f knote.yml
        kubectl apply -f minio.yml
        kubectl apply -f mongo.yml





